use graphics::{clear, CharacterCache, Context};
use piston::Key;
use piston_window::{G2d, Glyphs};
use rand::Rng;

use std::{thread, time::Duration};

use crate::bus::Bus;
use crate::cartridge::Cartridge;
use crate::cpu::Cpu6502;
use crate::video::{draw_text, Frame, Pixel, Video, BLACK_PIXEL};

pub const GAME_CODE: [u8; 309] = [
    /*
    0x0   0x1   0x2   0x3   0x4   0x5   0x6   0x7   0x8   0x9   0xA   0xB   0xC   0xD   0xE   0xF */
    0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
    0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
    0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
    0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
    0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
    0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
    0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
    0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
    0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
    0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
    0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
    0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
    0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
    0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
    0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
    0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
    0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
    0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
    0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
    0xea, 0xca, 0xd0, 0xfb, 0x60,
];

fn color(byte: u8) -> Pixel {
    match byte {
        0 => Pixel::new(50, 50, 50),        // sdl2::pixels::Color::BLACK,
        1 => Pixel::new(255, 255, 255),     //  sdl2::pixels::Color::WHITE,
        2 | 9 => Pixel::new(100, 100, 100), //  sdl2::pixels::Color::GREY,
        3 | 10 => Pixel::new(255, 0, 0),    //  sdl2::pixels::Color::RED,
        4 | 11 => Pixel::new(0, 255, 0),    //  sdl2::pixels::Color::GREEN,
        5 | 12 => Pixel::new(0, 0, 255),    //  sdl2::pixels::Color::BLUE,
        6 | 13 => Pixel::new(255, 0, 255),  //  sdl2::pixels::Color::MAGENTA,
        7 | 14 => Pixel::new(255, 255, 0),  //  sdl2::pixels::Color::YELLOW,
        _ => Pixel::new(0, 255, 255),       //  sdl2::pixels::Color::CYAN,
    }
}

pub struct SnakeGame {
    pub cpu: Cpu6502,
    running: bool,
}

// Draws
impl SnakeGame {
    fn draw_screen(&mut self, context: Context, gl: &mut G2d) {
        let mut frame = Frame::new(32, 32);

        for color_y in 0..32 {
            for color_x in 0..32 {
                let offset = 0x0200 + (color_y * 32) + color_x;
                let pixel = self.cpu.read(offset as u16);

                frame.set_pixel(color_x, color_y, color(pixel));
            }
        }

        frame.render(50, 50, 10.0, context, gl);
    }
}

impl Video for SnakeGame {
    fn draw(&mut self, context: Context, gl: &mut G2d, glyphs: &mut Glyphs) {
        clear(BLACK_PIXEL.get_color(), gl);
        if self.running {
            if self.cpu.pc == 0x0638 {
                self.running = false;
                return;
            }

            let mut rng = rand::thread_rng();
            let result = rng.gen_range(1, 16);
            self.cpu.write(0xfe, result);

            self.cpu.cpu_clock();

            thread::sleep(Duration::new(0, 70_000));
        }

        // Draws
        self.draw_screen(context, gl);
        draw_text(500, 200, "HELLO WORLD", Pixel::red(), context, gl, glyphs);
    }

    fn on_buttom_press(&mut self, key: Key) {
        match key {
            Key::Up => self.cpu.write(0xFF, 0x77),
            Key::Down => self.cpu.write(0xFF, 0x73),
            Key::Right => self.cpu.write(0xFF, 0x61),
            Key::Left => self.cpu.write(0xFF, 0x64),
            Key::P => self.running = !self.running,
            Key::N => {
                self.cpu.cpu_clock();
                while self.cpu.cycles > 0 {
                    self.cpu.cpu_clock();
                }
            }
            _ => {}
        }
    }
}

impl SnakeGame {
    pub fn new() -> SnakeGame {
        let cartridge = Cartridge::empty();
        let bus = Bus::new(cartridge);
        SnakeGame {
            cpu: Cpu6502::new_with_bus(bus),
            running: false,
        }
    }

    pub fn start(&mut self) {
        self.cpu.reset();
        self.cpu.load(0x0600, Vec::from(GAME_CODE));
        self.cpu.pc = 0x0600;

        self.cpu.write(0x0200, 3);
        self.cpu.write(0x0200 + (31 * 32) + 31, 3);

        self.start_loop("Snake Game");
    }
}
